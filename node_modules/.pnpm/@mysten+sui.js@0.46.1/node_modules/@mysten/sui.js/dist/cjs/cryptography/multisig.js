"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var multisig_exports = {};
__export(multisig_exports, {
  decodeMultiSig: () => decodeMultiSig
});
module.exports = __toCommonJS(multisig_exports);
var import_bcs = require("@mysten/bcs");
var import_bcs2 = require("../bcs/index.js");
var import_publickey = require("../keypairs/ed25519/publickey.js");
var import_publickey2 = require("../keypairs/secp256k1/publickey.js");
var import_publickey3 = require("../keypairs/secp256r1/publickey.js");
var import_signature_scheme = require("./signature-scheme.js");
function decodeMultiSig(signature) {
  const parsed = (0, import_bcs.fromB64)(signature);
  if (parsed.length < 1 || parsed[0] !== import_signature_scheme.SIGNATURE_SCHEME_TO_FLAG["MultiSig"]) {
    throw new Error("Invalid MultiSig flag");
  }
  const multisig = import_bcs2.bcs.MultiSig.parse(parsed.slice(1));
  let res = new Array(multisig.sigs.length);
  for (let i = 0; i < multisig.sigs.length; i++) {
    let s = multisig.sigs[i];
    let pk_index = as_indices(multisig.bitmap).at(i);
    let pk_bytes = Object.values(multisig.multisig_pk.pk_map[pk_index].pubKey)[0];
    const scheme = Object.keys(s)[0];
    if (scheme === "MultiSig") {
      throw new Error("MultiSig is not supported inside MultiSig");
    }
    if (scheme === "ZkLogin") {
      throw new Error("ZkLogin is not supported inside MultiSig");
    }
    const SIGNATURE_SCHEME_TO_PUBLIC_KEY = {
      ED25519: import_publickey.Ed25519PublicKey,
      Secp256k1: import_publickey2.Secp256k1PublicKey,
      Secp256r1: import_publickey3.Secp256r1PublicKey
    };
    const PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[scheme];
    res[i] = {
      signatureScheme: scheme,
      signature: Uint8Array.from(Object.values(s)[0]),
      pubKey: new PublicKey(pk_bytes),
      weight: multisig.multisig_pk.pk_map[pk_index].weight
    };
  }
  return res;
}
function as_indices(bitmap) {
  if (bitmap < 0 || bitmap > 1024) {
    throw new Error("Invalid bitmap");
  }
  let res = [];
  for (let i = 0; i < 10; i++) {
    if ((bitmap & 1 << i) !== 0) {
      res.push(i);
    }
  }
  return Uint8Array.from(res);
}
//# sourceMappingURL=multisig.js.map
