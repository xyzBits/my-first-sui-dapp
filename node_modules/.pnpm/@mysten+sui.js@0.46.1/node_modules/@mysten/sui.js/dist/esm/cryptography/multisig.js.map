{
  "version": 3,
  "sources": ["../../../src/cryptography/multisig.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signature-scheme.js';\nimport type { SignatureScheme } from './signature-scheme.js';\nimport type { SignaturePubkeyPair } from './utils.js';\n\n/// Decode a multisig signature into a list of signatures, public keys and flags.\nexport function decodeMultiSig(signature: string): SignaturePubkeyPair[] {\n\tconst parsed = fromB64(signature);\n\tif (parsed.length < 1 || parsed[0] !== SIGNATURE_SCHEME_TO_FLAG['MultiSig']) {\n\t\tthrow new Error('Invalid MultiSig flag');\n\t}\n\n\tconst multisig = bcs.MultiSig.parse(parsed.slice(1));\n\tlet res: SignaturePubkeyPair[] = new Array(multisig.sigs.length);\n\tfor (let i = 0; i < multisig.sigs.length; i++) {\n\t\tlet s = multisig.sigs[i];\n\t\tlet pk_index = as_indices(multisig.bitmap).at(i);\n\t\tlet pk_bytes = Object.values(multisig.multisig_pk.pk_map[pk_index as number].pubKey)[0];\n\t\tconst scheme = Object.keys(s)[0] as SignatureScheme;\n\n\t\tif (scheme === 'MultiSig') {\n\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t}\n\n\t\tif (scheme === 'ZkLogin') {\n\t\t\tthrow new Error('ZkLogin is not supported inside MultiSig');\n\t\t}\n\n\t\tconst SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n\t\t\tED25519: Ed25519PublicKey,\n\t\t\tSecp256k1: Secp256k1PublicKey,\n\t\t\tSecp256r1: Secp256r1PublicKey,\n\t\t};\n\n\t\tconst PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[scheme];\n\n\t\tres[i] = {\n\t\t\tsignatureScheme: scheme,\n\t\t\tsignature: Uint8Array.from(Object.values(s)[0]),\n\t\t\tpubKey: new PublicKey(pk_bytes),\n\t\t\tweight: multisig.multisig_pk.pk_map[pk_index as number].weight,\n\t\t};\n\t}\n\treturn res;\n}\n\nfunction as_indices(bitmap: number): Uint8Array {\n\tif (bitmap < 0 || bitmap > 1024) {\n\t\tthrow new Error('Invalid bitmap');\n\t}\n\tlet res: number[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tif ((bitmap & (1 << i)) !== 0) {\n\t\t\tres.push(i);\n\t\t}\n\t}\n\treturn Uint8Array.from(res);\n}\n"],
  "mappings": "AAGA,SAAS,eAAe;AAExB,SAAS,WAAW;AACpB,SAAS,wBAAwB;AACjC,SAAS,0BAA0B;AACnC,SAAS,0BAA0B;AACnC,SAAS,gCAAgC;AAKlC,SAAS,eAAe,WAA0C;AACxE,QAAM,SAAS,QAAQ,SAAS;AAChC,MAAI,OAAO,SAAS,KAAK,OAAO,CAAC,MAAM,yBAAyB,UAAU,GAAG;AAC5E,UAAM,IAAI,MAAM,uBAAuB;AAAA,EACxC;AAEA,QAAM,WAAW,IAAI,SAAS,MAAM,OAAO,MAAM,CAAC,CAAC;AACnD,MAAI,MAA6B,IAAI,MAAM,SAAS,KAAK,MAAM;AAC/D,WAAS,IAAI,GAAG,IAAI,SAAS,KAAK,QAAQ,KAAK;AAC9C,QAAI,IAAI,SAAS,KAAK,CAAC;AACvB,QAAI,WAAW,WAAW,SAAS,MAAM,EAAE,GAAG,CAAC;AAC/C,QAAI,WAAW,OAAO,OAAO,SAAS,YAAY,OAAO,QAAkB,EAAE,MAAM,EAAE,CAAC;AACtF,UAAM,SAAS,OAAO,KAAK,CAAC,EAAE,CAAC;AAE/B,QAAI,WAAW,YAAY;AAC1B,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC5D;AAEA,QAAI,WAAW,WAAW;AACzB,YAAM,IAAI,MAAM,0CAA0C;AAAA,IAC3D;AAEA,UAAM,iCAAiC;AAAA,MACtC,SAAS;AAAA,MACT,WAAW;AAAA,MACX,WAAW;AAAA,IACZ;AAEA,UAAM,YAAY,+BAA+B,MAAM;AAEvD,QAAI,CAAC,IAAI;AAAA,MACR,iBAAiB;AAAA,MACjB,WAAW,WAAW,KAAK,OAAO,OAAO,CAAC,EAAE,CAAC,CAAC;AAAA,MAC9C,QAAQ,IAAI,UAAU,QAAQ;AAAA,MAC9B,QAAQ,SAAS,YAAY,OAAO,QAAkB,EAAE;AAAA,IACzD;AAAA,EACD;AACA,SAAO;AACR;AAEA,SAAS,WAAW,QAA4B;AAC/C,MAAI,SAAS,KAAK,SAAS,MAAM;AAChC,UAAM,IAAI,MAAM,gBAAgB;AAAA,EACjC;AACA,MAAI,MAAgB,CAAC;AACrB,WAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC5B,SAAK,SAAU,KAAK,OAAQ,GAAG;AAC9B,UAAI,KAAK,CAAC;AAAA,IACX;AAAA,EACD;AACA,SAAO,WAAW,KAAK,GAAG;AAC3B;",
  "names": []
}
